# Синтаксис

Синтаксис в poonya почти эквивалентен большинству языков программирования, со своими специфическими особенностями. Синтаксис в poonya можно разделить на две категории:
* Блочный синтаксис
* Синтаксис выражения

## Блочный синтаксис ~[block]
Блочный синтаксис распостраняется только на блоки кода poonya. Обычно они представляют из себя код poonya в `{}` - фигурных скобках, но есть исключения в виде главного блока, который, по понятным причинам, заключать в скобки не надо.

Блочный синтаксис представляет из себя последовательность инструкций, которые выполняются интерпритатором poonya в заданом порядке.

### Инструкции ~[instructions]
Инструкции позволяют определить базовое поведение шаблонов на уровне основного блока. Инструкции исполняются последовательно, poonya не поддверживает асинхронность, поэтому асинхронные инструкции(скажем, если вы создали асинхронную функцию как функцию статической библиотеки), то шаблонизатор будет ждать пока последняя асинхрнная инструкция не будет выполнена.

### Инструкция if ~[if]
`if` - представляет из себя инструкцию условного блока. Используется она следующим образом: `if`(`<`**условие**`>`) { `//` code `//` } `?`**else** `?`**if** (`<`**условие**`>`) { `//` code `//` }. `if` будет выполнена, если условие `<`**условие**`>` будет выполнено. После завершения выполнения инструкции, интерпритатор перейдет к выполнению следующей инструкции.

```js
set i = 5;

if(i = 5){
    > '`i` это 5';
} else {
    > '`i` это не 5';
}
```

Обратите внимание что конструкцию `if ... else` можно совмещать:

```js
set i = 6;

if(i = 5){
    > '`i` это 5';
} else if(i = 6){
    > '`i` это 6';
} else {
    > '`i` это не 5 и не 6';
}
```

Таким образом можно продолжать до бесконечности. 

### Инструкция while ~[while]
`while` - представляет из себя инструкцию условного цикла. Используется она следующим образом: `while`(`<`**условие**`>`) { `//` code `//` }. `while` будет сполнятся до тех пор, пока условие `<`**условие**`>` выполняется. После завершения выполнения инструкции, интерпритатор перейдет к выполнению следующей инструкции.

```js
set i = 0;

while(i < 100){
    > 'i = ' + i + endl;
}
```

\- выведет `i = 0...99`, обратите внимание 100 не включено, поскольку при `i == 100` условие перестает выполнятся.

### Инструкция repeat ~[repeat]
`repeat` - представляет из себя инструкцию диапазонного цикла. Используется она следующим образом: `repeat`(`<`**с индекс**`>`; `<`**по индекс**`>`) { `//` code `//` }. `repeat` будет выполнятся (`<`**по индекс**`>` - `<`**с индекс**`>`) раз. В теле цикла, так-же доступна переменная `current`, которая содержит текущую итерируемую позицию. После завершения выполнения инструкции, интерпритатор перейдет к выполнению следующей инструкции.

```js
repeat(0; 100){
    > 'i = ' + current + endl;
}
```

\- выведет `i = 0...99`.

### Инструкция set ~[set]
`set` - представляет из себя инструкцию объявления переменной, и её инициазацию. Используется она следующим образом: `set` `<`**название переменной**`>` = `<`**значение**`>`. Установка действует для текущей области действия и дочерних областей действия. Вы можете использовать эту инструкцию для переопределения переменной в текущей области действия.

```js
set i = 2 + 2 * 2;

> i;
```

Код выше выведет `6`;

### Оператор вывода ~[out]
Оператор вывода, представляет из себя оператор `>`, который интерпритируется как команда вывода в поток вывода, который возвращает шаблон. Используется оператор вывода следующим образом: `>` `<`**выражение**`>`.

```js
> 2 + 2 * 2;
```

Код выше выведет `6`;

### Оператор добавления ~[add]
Оператор добавления, представляет из себя оператор `<-`, который интерпритируется как команда добавления в массив, переменная с которым должна быть расположена слева, а добавляемое значение справа. Используется оператор добавления следующим образом: `<`**массив подобный**`>` `<-` `<`**выражение**`>`.

```js
set array = Array -> *;

array <- 5;

> array;
```

Код выше выведет `[ 5 ]`;

### Синтаксис выражений ~[expression]
Под синтаксисом выражения я имею ввиду синтаксис который используется для формирования выражения. Это может быть последовательость операндов и операторов: `2 + 2 = 4`, или логическое выражение `2 < 5` а так-же смешанные `2 + 2 * 2 = 6 = 0 + 1`. Выражения позволяют получить промеждуточное значение в в памяти, которое можно будет позже присоить переменной или присвоить функции.

### Литералы ~[literals]
Литералы - это значения заданные в коде, как пример можно привести `true` - булевый литерал, который обозначет логическое `да`. Так-же литералом можно назвать любое использование цифр, булевых, и null, значений.

### Операторы ~[operators]
Операторы это часть выражения которая находится между двух операндов: `2 + 2` - где + это оператор. В poonya есть 9 операторов: `-` `+` `*` `/` `>` `<` `<=` `>=` `=`. Обратите внимание что нет оператора `==`, я посчитал что этот оператор не является предметом первой необходимости. Поэтому вместо него в poonya существует универсальный опреатор `=` - который в выражении будет обозначать желание сравнить левый и правый операнд.

<img src='static/data/routes/poonya/images/operands.png' style='filter: var(--imgs-def-filter)'>

### Оператор сложения ~[plus]
Оператор сложения выполняет сложение левого и правого операнда:

```js
> 2 + 5;
```

Выведет [`7`].

### Оператор вычитания ~[minus]
Оператор вычитания выполняет вычитание правого операнда из левого:

```js
> 2 - 5;
```

Выведет [`-3`].

### Оператор умножения ~[mult]
Оператор умножения выполняет умножение левого и правого операнда. 

> Обратите внимание что приоритет операций умножения и деления, выполняются с повышенным приоритетом.
> Выражение 2 + 2 * 2 можно записать как 2 + (2 * 2) чтобы лучше понять как это работает.

```js
> 2 + 2 * 2;
```

Выведет [`6`].

### Оператор деления ~[div]
Оператор деления выполняет деление левого операнда на правый. 

> Обратите внимание что приоритет операций умножения и деления, выполняются с повышенным приоритетом.
> Выражение 2 + 2 / 2 можно записать как 2 + (2 / 2) чтобы лучше понять как это работает.

```js
> 2 + 2 / 2;
```

Выведет [`3`].

### Оператор больше ~[bigger]
Оператор `больше` сравнивает левый и правый операнд, если левый операнд больше правого то возвращает `true`;

> Обратите внимание, оператор вывода для исполняемого блока, в блоке выражения преобразуется в опреатор больше.

```js
> 3 > 3;
```

Выведет [`false`].

### Оператор меньше ~[less]
Оператор `меньше` сравнивает левый и правый операнд, если левый операнд меньше правого то возвращает `true`;

```js
> 3 < 3;
```

Выведет [`false`].

### Оператор больше или равно ~[e_bigger]
Оператор `больше или равно` сравнивает левый и правый операнд, если левый операнд больше или равен правому то возвращает `true`;

```js
> 3 >= 3;
```

Выведет [`true`].

### Оператор меньше или равно ~[e_less]
Оператор `меньше или равно` сравнивает левый и правый операнд, если левый операнд меньше или равен правому то возвращает `true`;

```js
> 3 <= 3;
```

Выведет [`true`].

### Оператор равно ~[e_equ]
Оператор `равно` сравнивает левый и правый операнд, если левый операнд равен правому то возвращает `true`;

```js
> 3 = 3;
```

Выведет [`true`].

### Тернарный оператор ~[ternar]
Тернартный оператор позволяет получать условное значение прямо в выражении, имеет следущий синтаксис: `<`**expression**`>` ? `<`*true* **expression**`>` : `<`*false* **expression**`>`. Оно работает эквивалентно инструкции if, но имеет возвращаемое значение. Так-же вы можете вкладывать тернарные операторы друг в друга, создавая подобные конструкции `true ? flase ? fakse : true : false`;

```js
> 1 === 2 ? '1 это 2' : '1 это не 2';
```

Выведет `[`"**1 это не 2**"`]`.

### Группа вывода ~[output_group]
Группа вывода позволяет перехватывать вывод того кода, который находится в исполняемом блоке группы вывода. Для создания группы вывода, которую не нужно перед возвратом обрабатывать, вы можете просто заключить ваш код в `{}` фигруные скобки. Если вы хоите как либо обработать вывод, вы можете указать функцию для обработки перед фигруными скобками. `<`**handler**`>`***?*** `<-`***?*** `{` `<`**body**`>` `}`;

> Пока есть две встроенные фукнции для обработки: concat - просто объеденяет вывод как строку и array - просто выводит данные в сыром виде как массив, без обработки перед выводом. Все функции для обработки можно найти в объекте joiners

```js
> {
    > 1;
    > 2;
    > 3;
}
```

Выведет [[`1`, `2`, `3`]].

Вы так-же можете указать обработчик:
```js
> joiners.concat <- {
    > 1;
    > 2;
    > 3;
}
```

Выведет [`123`].

### Объекты, конструкторы оьъектов ~[objects_constr]
Объекты можно создать, указав целевой прототип, и данные для инициализации. `<`**prototype**`>` -> **level** -> `value`, **level** -> `value`, --> **next level**...; Тоесть свойства объекто передаются путем поуровневой передачи свойств:

> Вы так-же можете создавать специальные типы объектов, например массив или строка. Но что косается строк числе и других примитивов, то они ***пока*** работают как обычные объекты. А что касается массива, то его отличие от обычного объекта в том что никакие другие индексы, кроме чисел, не принемаются.

```js
    set s = Obect ->
                key -> 'value',
                key1 -> 'value1';

    > s;
```

Выведет(в JSON) `{`
    **"**`key`**"**`:` **"**`value`**"**,
    **"**`key1`**"**`:` **"**`value1`**"**
`}`;

Также можно использовать сокращенную нотацию(только для объекта):

```js
    set s = ->
            key -> 'value',
            key1 -> 'value1';

    > s;
```

Вывод будет идентичным.

### Дополнение ~[end]
Я постарался сделать синтаксис `poonya` не сильно сложным и как можно более дружелюбным к синтаксисам других языков. Впринципе это все по синтаксису, спасибо за внимание.